/* eslint-disable */
var chopinMap = {
  309  : 3,
  1079 : 4,
  1226 : 272,
  1292 : 271,
  1340 : 5,
  1342 : 6,
  1380 : 270,
  1455 : 269,
  1554 : 268,
  1640 : 267,
  1746 : 266,
  1792 : 64,
  1819 : 63,
  1854 : 265,
  1862 : 62,
  1927 : 54,
  1958 : 61,
  1959 : 53,
  1971 : 264,
  1989 : 56,
  2003 : 55,
  2041 : 60,
  2063 : 52,
  2108 : 263,
  2124 : 262,
  2147 : 59,
  2152 : 261,
  2174 : 58,
  2238 : 251,
  2241 : 57,
  2250 : 49,
  2256 : 50,
  2271 : 34,
  2304 : 260,
  2326 : 33,
  2333 : 110,
  2360 : 48,
  2373 : 250,
  2388 : 46,
  2391 : 65,
  2402 : 109,
  2405 : 258,
  2420 : 47,
  2426 : 32,
  2436 : 108,
  2449 : 252,
  2469 : 86,
  2472 : 259,
  2488 : 168,
  2490 : 131,
  2497 : 45,
  2521 : 130,
  2526 : 107,
  2528 : 84,
  2533 : 85,
  2542 : 209,
  2546 : 257,
  2551 : 249,
  2567 : 87,
  2589 : 210,
  2591 : 106,
  2596 : 256,
  2600 : 167,
  2601 : 44,
  2607 : 17,
  2620 : 129,
  2627 : 208,
  2633 : 76,
  2638 : 31,
  2640 : 189,
  2647 : 187,
  2651 : 104,
  2660 : 40,
  2663 : 90,
  2671 : 38,
  2676 : 128,
  2691 : 83,
  2693 : 91,
  2694 : 188,
  2695 : 97,
  2700 : 169,
  2702 : 255,
  2711 : 35,
  2713 : 89,
  2718 : 166,
  2723 : 253,
  2726 : 39,
  2736 : 19,
  2739 : 143,
  2744 : 12,
  2762 : 133,
  2764 : 248,
  2775 : 207,
  2780 : 103,
  2793 : 186,
  2796 : 132,
  2810 : 254,
  2811 : 142,
  2816 : 88,
  2824 : 74,
  2825 : 99,
  2829 : 11,
  2830 : 165,
  2837 : 127,
  2840 : 96,
  2842 : 36,
  2845 : 42,
  2847 : 37,
  2868 : 190,
  2869 : 100,
  2870 : 98,
  2877 : 30,
  2883 : 41,
  2900 : 102,
  2914 : 206,
  2945 : 145,
  2951 : 242,
  2956 : 126,
  2959 : 185,
  2960 : 194,
  2977 : 247,
  2980 : 73,
  2991 : 101,
  2992 : 20,
  2995 : 141,
  3001 : 7,
  3016 : 163,
  3028 : 95,
  3029 : 144,
  3031 : 198,
  3042 : 162,
  3043 : 9,
  3048 : 205,
  3054 : 211,
  3060 : 241,
  3071 : 246,
  3080 : 235,
  3085 : 236,
  3088 : 137,
  3089 : 111,
  3091 : 92,
  3094 : 171,
  3105 : 94,
  3110 : 193,
  3113 : 14,
  3119 : 81,
  3125 : 184,
  3131 : 170,
  3133 : 192,
  3144 : 240,
  3146 : 195,
  3152 : 245,
  3158 : 161,
  3162 : 21,
  3165 : 29,
  3172 : 134,
  3173 : 177,
  3178 : 191,
  3197 : 72,
  3198 : 25,
  3202 : 234,
  3204 : 136,
  3208 : 197,
  3212 : 139,
  3217 : 199,
  3225 : 8,
  3238 : 237,
  3242 : 140,
  3253 : 146,
  3266 : 178,
  3267 : 196,
  3271 : 78,
  3274 : 204,
  3283 : 239,
  3293 : 176,
  3297 : 28,
  3304 : 244,
  3314 : 154,
  3324 : 215,
  3328 : 201,
  3334 : 27,
  3338 : 183,
  3339 : 233,
  3360 : 24,
  3363 : 135,
  3364 : 26,
  3367 : 179,
  3371 : 238,
  3381 : 243,
  3386 : 172,
  3387 : 66,
  3405 : 200,
  3415 : 80,
  3430 : 229,
  3431 : 159,
  3443 : 175,
  3446 : 220,
  3448 : 71,
  3449 : 148,
  3453 : 153,
  3457 : 158,
  3458 : 214,
  3460 : 79,
  3462 : 226,
  3469 : 232,
  3475 : 138,
  3480 : 23,
  3494 : 124,
  3497 : 223,
  3501 : 221,
  3507 : 228,
  3508 : 222,
  3514 : 203,
  3522 : 216,
  3546 : 180,
  3560 : 157,
  3563 : 219,
  3568 : 230,
  3572 : 231,
  3575 : 202,
  3576 : 151,
  3586 : 174,
  3590 : 147,
  3591 : 155,
  3606 : 152,
  3610 : 182,
  3614 : 225,
  3623 : 173,
  3624 : 69,
  3625 : 150,
  3633 : 227,
  3635 : 213,
  3644 : 156,
  3667 : 70,
  3679 : 67,
  3701 : 218,
  3751 : 224,
  3777 : 149,
  3810 : 212,
  3821 : 181,
  3841 : 123,
  3848 : 217,
  3977 : 119,
  4010 : 113,
  4138 : 122,
  4261 : 121,
  4287 : 120,
  4356 : 118,
  4447 : 114,
  4632 : 115,
  4730 : 117,
  4835 : 116,
};

var chopinSeq = [
  17,
  39,
  883,
  1186,
  1298,
  3111,
  3188,
  2954,
  3317,
  3848,
  3810,
  3875,
  3921,
  3730,
  3375,
  3426,
  4576,
  5124,
  5892,
  5888,
  5595,
  5212,
  4848,
  4598,
  4559,
  4540,
  4359,
  4032,
  3689,
  3355,
  3065,
  3046,
  2888,
  3150,
  3154,
  3087,
  2879,
  3289,
  3125,
  3641,
  3458,
  3339,
  3085,
  2852,
  2801,
  2770,
  2772,
  2609,
  2523,
  2385,
  2323,
  2204,
  2187,
  2344,
  2706,
  2883,
  2901,
  2712,
  2526,
  2347,
  2217,
  2213,
  2189,
  2339,
  2619,
  2609,
  3312,
  4249,
  4516,
  4485,
  4169,
  3871,
  3621,
  3339,
  3202,
  3036,
  3503,
  3573,
  3956,
  3824,
  3528,
  3240,
  3003,
  2940,
  3244,
  3203,
  3354,
  3255,
  3161,
  3015,
  3093,
  2967,
  3464,
  3380,
  3193,
  3033,
  3265,
  3131,
  3127,
  3246,
  3093,
  2946,
  2816,
  2699,
  2702,
  2684,
  2570,
  2487,
  2585,
  2809,
  2762,
  3005,
  3480,
  3912,
  4176,
  4361,
  3999,
  3701,
  3855,
  3782,
  3698,
  3590,
  3292,
  3020,
  2781,
  2670,
  2703,
  2584,
  2438,
  2336,
  2347,
  2404,
  4139,
  4664,
  4422,
  4607,
  4697,
  4309,
  4123,
  3779,
  3446,
  3204,
  3252,
  3057,
  3298,
  3549,
  3373,
  3677,
  3522,
  3659,
  3503,
  3311,
  3236,
  3299,
  3568,
  3672,
  3540,
  3392,
  3239,
  3089,
  2965,
  2930,
  2856,
  2811,
  2752,
  2656,
  2543,
  2663,
  2898,
  2848,
  2881,
  3083,
  3035,
  2902,
  2780,
  2662,
  3212,
  3591,
  4134,
  4438,
  4165,
  3791,
  3579,
  3328,
  3073,
  2883,
  2947,
  2946,
  3103,
  3148,
  2965,
  2812,
  2631,
  2501,
  2600,
  2838,
  2669,
  3106,
  3156,
  3163,
  3260,
  3234,
  3006,
  2810,
  2650,
  2656,
  2513,
  2788,
  3269,
  3910,
  4050,
  3847,
  3621,
  3471,
  3697,
  3994,
  3807,
  3866,
  3693,
  3549,
  3438,
  3392,
  3441,
  3444,
  3445,
  3510,
  3364,
  3236,
  3398,
  3382,
  3269,
  3137,
  3032,
  3010,
  2996,
  3162,
  3258,
  3194,
  3047,
  2918,
  2817,
  2677,
  2802,
  2778,
  2707,
  2566,
  2458,
  2330,
  2349,
  2274,
  2513,
  2811,
  2900,
  2904,
  2935,
  2734,
  2516,
  2357,
  2210,
  2062,
  1955,
  1845,
  1758,
  1657,
  1557
];

const app = () => {

  // fork getUserMedia for multiple browser versions, for those
  // that need prefixes

  // Copied from MDN: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia
  // This is a legacy method. 
  // Please use the newer navigator.mediaDevices.getUserMedia() instead. 
  // While technically not deprecated, this old callback version is marked as such, 
  // since the specification strongly encourages using the newer promise returning version.

  // TODO: Replace the deprecated method of asking for media permission
  // Refer to: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
  // To update the media reference below.

  navigator.getUserMedia = (navigator.getUserMedia ||
                            navigator.webkitGetUserMedia ||
                            navigator.mozGetUserMedia ||
                            navigator.msGetUserMedia);

  // set up forked web audio context, for multiple browsers
  // window. is needed otherwise Safari explodes

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const voiceSelect = document.getElementById('voice');
  let source;
  // let stream;

  // set up the different audio nodes we will use for the app

  const analyser = audioCtx.createAnalyser();
  analyser.minDecibels = -90;
  analyser.maxDecibels = -10;
  analyser.smoothingTimeConstant = 0.85;

  // const distortion = audioCtx.createWaveShaper();
  // const gainNode = audioCtx.createGain();
  // const biquadFilter = audioCtx.createBiquadFilter();
  // const convolver = audioCtx.createConvolver();

  // distortion curve for the waveshaper, thanks to Kevin Ennis
  // http://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion

  function makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const nSamples = 44100;
    const curve = new Float32Array(nSamples);
    const deg = Math.PI / 180;
    let i = 0;
    let x = null;
    for (; i < nSamples; i += 1) {
      x = (i * 2) / (nSamples - 1);
      curve[i] = 3 + ((k * x * 20 * deg) / (Math.PI + (k * Math.abs(x))));
    }
    return curve;
  }

  // grab audio track via XHR for convolver node

  let soundSource;
  let concertHallBuffer;

  // const ajaxRequest = new XMLHttpRequest();

  // ajaxRequest.open('GET', 'https://mdn.github.io/voice-change-o-matic/audio/concert-crowd.ogg', true);

  // ajaxRequest.responseType = 'arraybuffer';


  // ajaxRequest.onload = () => {
  //   const audioData = ajaxRequest.response;

  //   audioCtx.decodeAudioData(audioData, (buffer) => {
  //     concertHallBuffer = buffer;
  //     soundSource = audioCtx.createBufferSource();
  //     soundSource.buffer = concertHallBuffer;    
  //     soundSource.connect(audioCtx.destination);
  //     // soundSource.loop = true;
  //     soundSource.start();
  //   }, (e) => { console.log(`Error with decoding audio data ${e.err}`); });


  // };

  // ajaxRequest.send();

  // set up canvas context for visualizer

  const canvas = document.querySelector('.visualizer');
  const canvasCtx = canvas.getContext('2d');

  const intendedWidth = document.querySelector('.audio-wrapper').clientWidth;

  canvas.setAttribute('width', intendedWidth);

  const visualSelect = document.getElementById('visual');

  let drawVisual;

  // function voiceChange() {
  //   distortion.oversample = '4x';
  //   biquadFilter.gain.value = 0;
  //   convolver.buffer = undefined;

  //   const voiceSetting = voiceSelect.value;
  //   console.log(voiceSetting);

  //   if (voiceSetting === 'distortion') {
  //     distortion.curve = makeDistortionCurve(400);
  //   } else if (voiceSetting === 'convolver') {
  //     convolver.buffer = concertHallBuffer;
  //   } else if (voiceSetting === 'biquad') {
  //     biquadFilter.type = 'lowshelf';
  //     biquadFilter.frequency.value = 1000;
  //     biquadFilter.gain.value = 25;
  //   } else if (voiceSetting === 'off') {
  //     console.log('Voice settings turned off');
  //   }
  // }
/* <div>
  <label for="voice">Voice setting</label>
  <select id="voice" name="voice">
  <option value="distortion">Distortion</option>
  <option value="convolver">Reverb</option>
  <option value="biquad">Bass Boost</option>
  <option value="off" selected>Off</option>
  </select>
</div> */

  // Throttle the requestAnimationFrame
  let stop = false;
  let frameCount = 0;
  let fps, fpsInterval, startTime, now, then, elapsed; 
  let start = Date.now();

  function startAnimating(fps) {
    fpsInterval = 1000 / fps;
    then = window.performance.now();
    startTime = then;
    console.log(startTime);
    visualize();
  }

  var song = [];

  let currentTime = 0;

  function visualize() {

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;


    const visualSetting = visualSelect.value;
    console.log(visualSetting);

    if (visualSetting === 'sinewave') {
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      console.log(bufferLength);
      const dataArray = new Uint8Array(bufferLength);

      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

      const draw = () => {
        drawVisual = requestAnimationFrame(draw);

        analyser.getByteTimeDomainData(dataArray);

        canvasCtx.fillStyle = 'rgb(200, 200, 200)';
        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = 'rgb(0, 0, 0)';

        canvasCtx.beginPath();

        const sliceWidth = (WIDTH * 1.0) / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i += 1) {
          const v = dataArray[i] / 128.0;
          const y = (v * HEIGHT) / 2;

          if (i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(canvas.width, canvas.height / 2);
        canvasCtx.stroke();
      };

      draw();
    } else if (visualSetting === 'frequencybars') {
      analyser.fftSize = 32768;
      const bufferLengthAlt = analyser.frequencyBinCount;
      console.log(bufferLengthAlt);
      const dataArrayAlt = new Uint8Array(bufferLengthAlt);

      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

      const drawAlt = (newtime) => {
        if (stop) return;

        drawVisual = requestAnimationFrame(drawAlt); 

        now = newtime;
        elapsed = now - then;

        if (elapsed > fpsInterval) {

          then = now - (elapsed % fpsInterval);

          analyser.getByteFrequencyData(dataArrayAlt);

          canvasCtx.fillStyle = 'rgb(0, 0, 0)';
          canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

          const barWidth = (WIDTH / bufferLengthAlt) * 2.5;
          let barHeight;
          let x = 0;
          let freq = 0;
          let loci = null;

          for (let i = 0; i < bufferLengthAlt / 2; i += 1) {
            barHeight = dataArrayAlt[i];

            canvasCtx.fillStyle = `rgb(${(barHeight + 100)},50,50)`;
            canvasCtx.fillRect(x, (HEIGHT - barHeight) / 2, barWidth, barHeight / 2);

            x += barWidth + 1;
            
            // Add every frequency into a sum and push this "beat" into song array
            if (dataArrayAlt[i] > freq) {
              freq = dataArrayAlt[i];
              loci = i;
            }
          }
          console.log(dataArrayAlt)
          // freq += dataArrayAlt[Math.floor(loci / 2)];
          // song[freq] = Math.floor((Date.now() - start) / 1000);
          
          // console.log(freq, chopinSeq[currentTime]);
          // if (freq <= chopinSeq[currentTime] + 250 && freq >= chopinSeq[currentTime] - 250) {
          //   window.scrollTo(0, window.pageYOffset + 10);
          //   currentTime++;
          // } else {
          //   for (let i = Math.max(0, currentTime - 10); i < Math.max(currentTime + 5, currentTime + 10); i++) {
          //     if (freq <= chopinSeq[i] + 250 && freq >= chopinSeq[i] - 250) {
          //       window.scrollTo(0, window.pageYOffset + 10);
          //       currentTime = i;
          //       break;
          //     }
          //   }
          // }
          song.push(loci);
        }
      };

      drawAlt();
    } else if (visualSetting === 'off') {
      console.log('song:', song)
      canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
      canvasCtx.fillStyle = 'red';
      canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
    }
  }

  // main block for doing the audio recording

  const initializeRecording = () => {
    if (navigator.getUserMedia) {
      console.log('getUserMedia supported.');
      navigator.getUserMedia(
        // constraints - only audio needed for this app
        {
          audio: true,
        },

        // Success callback
        (stream) => {
          source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          // source.connect(audioCtx.destination);
          // analyser.connect(distortion);
          // distortion.connect(biquadFilter);
          // biquadFilter.connect(convolver);
          // convolver.connect(gainNode);
          // gainNode.connect(audioCtx.destination);

          startAnimating(5);
          // voiceChange();
        },

        // Error callback
        (err) => {
          console.log(`The following gUM error occured: ${err}`);
        },
      );
    } else {
      console.log('getUserMedia not supported on your browser!');
    }
  }

  // TODO: This function call will eventually be controlled by a button click

  initializeRecording();

  // event listeners to change visualize and voice settings

  visualSelect.onchange = () => {
    window.cancelAnimationFrame(drawVisual);
    startAnimating(5);
  };

  // voiceSelect.onchange = () => {
  //   voiceChange();
  // };

  // grab the mute button to use below

  const mute = document.querySelector('.mute');

  function voiceMute() {
    if (mute.id === 'active') {
      // gainNode.gain.value = 1;
      mute.id = 'muted';
      mute.innerHTML = 'Play';
      // Suspending the audio context doesn't lower the CPU overhead from the streaming..
      // How can we "suspend" the streaming without destroying the context to offload the CPU usage when not in use?
      // -- Setting Visualize Settings to "OFF" drops the CPU percentage down by 15%.
      // -- Essentially removing canvas will make the processing a lot smoother
      audioCtx.suspend();
    } else {
      // gainNode.gain.value = 0;
      mute.id = 'active';
      mute.innerHTML = 'Pause';
      audioCtx.resume();
    }
  }

  mute.onclick = voiceMute;
  mute.id = 'active';
}

export default app;